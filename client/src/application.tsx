import {useEffect, useState} from 'react'
import * as Automerge from "automerge";
import {BinaryChange} from "automerge";
import {Encryption, encryptionSecret} from "./encryption";
import {v4 as createUUID} from "uuid";
import { io } from "socket.io-client";
import axios from "axios";
import {Change, LocalStore} from "./storage/local-store";

interface NoteContent {
  title: string,
  body: string
}
interface Note extends NoteContent {
  id: string,
}

interface Document {
  notes: Automerge.Table<Note>
}

/**
 * Initial hardcoded change that adds the empty notes table.
 * Basically just the output of the following change:
 *  Automerge.change(Automerge.init(), (doc) => {doc.notes = new Automerge.Table()})
 */
const initialChange = new Uint8Array([
  133, 111,  74, 131, 191, 119, 137,  53,   1,  52,   0,  16,
  214,  48,  11, 127, 226, 164,  77,  31, 174, 240, 226, 115,
  159, 228, 238,  11,   1,   1, 230, 207, 239, 153,   6,   0,
  0,   5,  21,   7,  52,   1,  66,   2,  86,   2, 112,   2,
  127,   5, 110, 111, 116, 101, 115,   1, 127,   6, 127,   0,
  127,   0
]) as BinaryChange;
const [initialDoc] = Automerge.applyChanges<Document>(Automerge.init(), [initialChange]);

const localStore = new LocalStore();

// Setup broadcast channel to sync changes between tabs, windows etc
const browserChannel = new BroadcastChannel("changes");
const socket = io(import.meta.env.VITE_SERVER_URL);

function decryptChanges(encryptedChanges: Change[]): BinaryChange[] {
  return encryptedChanges.map(encryptedChange => {
    const change = Encryption.decryptText(encryptionSecret, encryptedChange.change).replaceAll("\"", "");
    return new Uint8Array([...atob(change)].map(char => char.charCodeAt(0))) as BinaryChange;
  });
}

/**
 * A dirty hack to get around Automerge + react state issues where repeating
 * the useEffect in strict mode repeats changes being applied and breaks as the document is then "outdated"
 * todo: look at proper, none hacky fix and a better way of handling Automerge in state.
 */
let setupOnce = false;
let serverSyncOnce = false;

function Application() {
  const [loading, setLoading] = useState<boolean>(true);
  const [doc, setDoc] = useState<Automerge.FreezeObject<Document>>(Automerge.clone(initialDoc));

  const [newNoteTitle, setNewNoteTitle] = useState<string>("");
  const [newNoteBody, setNewNoteBody] = useState<string>("");

  async function makeChange(changeFunc: Automerge.ChangeFn<Document>) {
    const newDoc = Automerge.change(doc, changeFunc);
    const rawChange = Automerge.getLastLocalChange(newDoc);

    const encodedChange = btoa(String.fromCharCode(...rawChange));
    const encryptedChange = Encryption.encryptData(encryptionSecret, encodedChange);
    const change: Change = {
      id: createUUID(),
      change: encryptedChange
    }
    setDoc(newDoc);
    await localStore.saveChange(change);

    console.log(`made change ${change.id}. broadcasting to channel and sending socket event`)
    browserChannel.postMessage({type: "change", data: change});
    socket.emit("change", change);
  }

  function editNoteTitle(noteId: string, updatedTitle: string) {
    makeChange((doc) => {
      const note = doc.notes.byId(noteId);
      note.title = updatedTitle;
    })
  }
  function editNoteBody(noteId: string, updatedBody: string) {
    makeChange((doc) => {
      const note = doc.notes.byId(noteId);
      note.body = updatedBody;
    })
  }
  function addNote(note: NoteContent) {
    makeChange((doc) => {
      // @ts-ignore - ignore missing id field, this is generated by Automerge
      doc.notes.add({
        title: note.title,
        body: note.body
      });
    })
  }
  function deleteNote(noteId: string) {
    makeChange((doc) => {
      doc.notes.remove(noteId);
    })
  }

  async function applyRemoteChanges(remoteEncryptedChanges: Change[]) {
    const changeIds = await localStore.loadAllChangeIds();
    for (const change of remoteEncryptedChanges) {
      if (!changeIds.includes(change.id)) {
        await localStore.saveChange(change);
      }
    }

    const encryptedChanges = await localStore.loadAllChanges();
    const changes = decryptChanges(encryptedChanges);
    const [newDoc] = Automerge.applyChanges<Document>(Automerge.clone(initialDoc), changes);
    setDoc(newDoc);
  }

  /**
   * Initial setup which does the following
   * - Loads the local changes
   * - Triggers a sync with the server
   * - Sets up the websocket connection to listen for new changes from the server and to be ready to emit changes
   * - Sets up a broadcast channel to broadcast changes to other running instances of the app (such as other tabs).
   */
  useEffect(() => {
    async function setup() {
      // Load changes from local
      const encryptedChanges = await localStore.loadAllChanges();
      const changes = decryptChanges(encryptedChanges);
      const [docFromStorage] = Automerge.applyChanges(Automerge.clone(initialDoc), changes);
      setDoc(docFromStorage);
      setLoading(false);
    }

    if (setupOnce) {
      setup();

      socket.on("change", (change: Change) => {
        console.log("received change from websocket: " + change.id);
        applyRemoteChanges([change]);
      });
      socket.on("changes", (changes: Change[]) => {
        console.log(`received changes from websocket: [${changes.map(c => c.id).join(",")}]`);
        applyRemoteChanges(changes);
      });
    }
    else {
      setupOnce = true;
    }
  }, []);

  useEffect(() => {
    async function syncWithServer() {
      // Sync up changes from server
      const localIds = await localStore.loadAllChangeIds();
      const serverIds: string[] = await axios.get(`${import.meta.env.VITE_SERVER_URL}/changes/ids`)
          .then(res => res.data);

      const newIdsOnServer = serverIds.filter(id => !localIds.includes(id));
      const newIdsOnClient = localIds.filter(id => !serverIds.includes(id));

      if (newIdsOnClient.length > 0) {
        const changesForServer = await localStore.loadChanges(newIdsOnClient);
        socket.emit("changes", changesForServer);
      }

      if (newIdsOnServer.length > 0) {
        const changesFromServer = await axios
          .get<Change[]>(`${import.meta.env.VITE_SERVER_URL}/changes`, {
            params: {
              ids: newIdsOnServer
            }
          })
          .then(res => res.data);
        applyRemoteChanges(changesFromServer);
      }
    }
    if (serverSyncOnce) {
      syncWithServer();
    }
    else {
      serverSyncOnce = true;
    }
  }, []);

  browserChannel.onmessage = (event) => {
    if (event.data.type === "change") {
      console.log("received change from broadcast channel: " + event.data.data.id);
      applyRemoteChanges([event.data.data]);
    }
  };

  return (
      <>
        <h1>notes</h1>
        {loading && <p>loading...</p>}
        <div>
          <div>
            <form
              onSubmit={(e) => {
                e.preventDefault()

                addNote({
                  title: newNoteTitle,
                  body: newNoteBody
                })
                setNewNoteTitle("");
                setNewNoteBody("");
              }}
            >
              <h2>New Note:</h2>
              <input value={newNoteTitle} onChange={(e) => {setNewNoteTitle(e.target.value)}}/>
              <textarea value={newNoteBody} onChange={(e) => {setNewNoteBody(e.target.value)}}/>
              <button type="submit">add</button>
            </form>
          </div>
          {doc.notes.map(note =>
            <div key={note.id}>
              <input value={note.title} onChange={(e) => {editNoteTitle(note.id, e.target.value)}}></input>
              <textarea value={note.body} onChange={(e) => {editNoteBody(note.id, e.target.value)}}></textarea>
              <button onClick={() => {
                deleteNote(note.id);
              }}>delete</button>
            </div>
          )}
        </div>
      </>
  )
}

export default Application
