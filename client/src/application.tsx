import {useEffect, useState} from 'react'
import * as Automerge from "automerge";
import {BinaryChange} from "automerge";
import {LocalStore} from "./local-store";
import {Encryption, encryptionSecret} from "./encryption";
import {v4 as createUUID} from "uuid";
import {Change} from "./local-store";
import { io } from "socket.io-client";
import axios from "axios";

interface NoteContent {
  title: string,
  body: string
}
interface Note extends NoteContent {
  id: string,
}

interface Document {
  notes: Automerge.Table<Note>
}

/**
 * Initial hardcoded change that adds the empty notes table.
 * Basically just the output of the following change:
 *  Automerge.change(Automerge.init(), (doc) => {doc.notes = new Automerge.Table()})
 */
const initialChange = new Uint8Array([
  133, 111,  74, 131, 191, 119, 137,  53,   1,  52,   0,  16,
  214,  48,  11, 127, 226, 164,  77,  31, 174, 240, 226, 115,
  159, 228, 238,  11,   1,   1, 230, 207, 239, 153,   6,   0,
  0,   5,  21,   7,  52,   1,  66,   2,  86,   2, 112,   2,
  127,   5, 110, 111, 116, 101, 115,   1, 127,   6, 127,   0,
  127,   0
]) as BinaryChange;
const [initialDoc] = Automerge.applyChanges<Document>(Automerge.init(), [initialChange]);

const localStore = new LocalStore();

// Setup broadcast channel to sync changes between tabs, windows etc
const browserChannel = new BroadcastChannel("changes");
const socket = io("http://localhost:3000");

function Application() {
  const [loading, setLoading] = useState<boolean>(true);
  const [doc, setDoc] = useState<Automerge.FreezeObject<Document>>(Automerge.clone(initialDoc));

  const [newNoteTitle, setNewNoteTitle] = useState<string>("");
  const [newNoteBody, setNewNoteBody] = useState<string>("");

  function makeChange(changeFunc: Automerge.ChangeFn<Document>) {
    const newDoc = Automerge.change(doc, changeFunc);
    const rawChange = Automerge.getLastLocalChange(newDoc);

    const encodedChange = btoa(String.fromCharCode(...rawChange));
    const encryptedChange = Encryption.encryptData(encryptionSecret, encodedChange);
    const change: Change = {
      id: createUUID(),
      change: encryptedChange
    }
    setDoc(newDoc);
    localStore.addChange(change);
    browserChannel.postMessage({type: "change", data: change});
    socket.emit("change", change);
  }

  function editNoteTitle(noteId: string, updatedTitle: string) {
    makeChange((doc) => {
      const note = doc.notes.byId(noteId);
      note.title = updatedTitle;
    })
  }
  function editNoteBody(noteId: string, updatedBody: string) {
    makeChange((doc) => {
      const note = doc.notes.byId(noteId);
      note.body = updatedBody;
    })
  }
  function addNote(note: NoteContent) {
    makeChange((doc) => {
      // @ts-ignore - ignore missing id field, this is generated by Automerge
      doc.notes.add({
        title: note.title,
        body: note.body
      });
    })
  }
  function deleteNote(noteId: string) {
    makeChange((doc) => {
      doc.notes.remove(noteId);
    })
  }

  function applyChanges(existingDoc: Automerge.FreezeObject<Document>, encryptedChanges: Change[]) {
    const changes: BinaryChange[] = encryptedChanges.map(encryptedChange => {
      const change = Encryption.decryptText(encryptionSecret, encryptedChange.change).replaceAll("\"", "");
      return new Uint8Array([...atob(change)].map(char => char.charCodeAt(0))) as BinaryChange;
    });
    const [newDoc] = Automerge.applyChanges<Document>(existingDoc, changes);
    setDoc(newDoc);
  }

  /**
   * Initial setup which does the following
   * - Loads the existing document snapshot if it exists
   * - Triggers the changes to be loaded in the background (which will update the state & snapshot if different)
   * - Triggers a background sync with the server (which will update the state & snapshot if different)
   * - Sets up the websocket connection to listen for new changes from the server and to be ready to emit changes
   * - Sets up a broadcast channel to broadcast changes to other running instances of the app (such as other tabs).
   */
  useEffect(() => {
    async function setup() {
      // Load changes from local
      const encryptedChanges = await localStore.loadAllChanges();
      applyChanges(Automerge.clone(initialDoc), encryptedChanges);
      setLoading(false);

      // Sync up changes from server
      const localIds = await localStore.loadAllChangeIds();
      const serverIds: string[] = await axios.get("http://localhost:3000/changes/ids")
          .then(res => res.data);

      const changeIdsOnServer = serverIds.filter(id => !localIds.includes(id));
      const changesIdsForServer = localIds.filter(id => !serverIds.includes(id));

      const changesForServer = await localStore.loadChanges(changesIdsForServer);
      socket.emit("changes", changesForServer);

      const changesFromServer = await axios
          .get<Change[]>("http://localhost:3000/changes", {
            params: {
              ids: changeIdsOnServer
            }
          })
          .then(res => res.data);
      applyChanges(doc, changesFromServer);
    }
    setup();
  }, []);

  browserChannel.onmessage = (event) => {
    console.log(event);
    if (event.data.type === "change") {
      applyChanges(doc, [event.data.data]);
    }
  };

  socket.on("change", (change) => {
    applyChanges(doc, [change]);
  });
  socket.on("changes", (changes) => {
    applyChanges(doc, changes);
  });

  return (
      <>
        <h1>notes</h1>
        {loading && <p>loading...</p>}
        <div>
          <div>
            <form
              onSubmit={(e) => {
                e.preventDefault()

                addNote({
                  title: newNoteTitle,
                  body: newNoteBody
                })
                setNewNoteTitle("");
                setNewNoteBody("");
              }}
            >
              <h2>New Note:</h2>
              <input value={newNoteTitle} onChange={(e) => {setNewNoteTitle(e.target.value)}}/>
              <textarea value={newNoteBody} onChange={(e) => {setNewNoteBody(e.target.value)}}/>
              <button type="submit">add</button>
            </form>
          </div>
          {doc.notes.map(note =>
            <div key={note.id}>
              <input value={note.title} onChange={(e) => {editNoteTitle(note.id, e.target.value)}}></input>
              <textarea value={note.body} onChange={(e) => {editNoteBody(note.id, e.target.value)}}></textarea>
              <button onClick={() => {
                deleteNote(note.id);
              }}>delete</button>
            </div>
          )}
        </div>
      </>
  )
}

export default Application
